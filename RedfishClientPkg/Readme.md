# UEFI Redfish Client EDK2 Implementation

## Introduction
UEFI Redfish Client EDK2 solution is implemented base on
[*EDK2 Redfish Foundation*](https://github.com/tianocore/edk2/blob/master/RedfishPkg/Readme.md),
the implementation utilizes the EFI protocols provided by EDK2 Redfish
Foundation to communicate with the Redfish service for creating, consuming, and
updating the Redfish properties which are managed by firmware. This solution
requests the instance of **EFI REST EX Protocol** through EFI Redfish Discover
Protocol and interacts with Redfish service using **EFI REST EX Protocol** later
on. The essential part of this implementation is to map the EDK2 HII options to
the corresponding Redfish properties that are already defined in the standard
Redfish schemas published by
[*DMTF Redfish working group*](https://www.dmtf.org/standards/redfish).
The advantage of this design is to strengthen the interoperability among the
servers produced by different OEMs when configuring the platform through Redfish
service. Using the properties defined in Redfish standard schema for configuring
platform reduces the overhead of Redfish client tools to have different
implementations in order to compliant with OEM servers. The solution also
reduces OEM-defined proprietary BIOS Attributes that lead to the divergence of
platform configuration namings in Redfish BIOS Attribute Registry, however,
those different namings refer to the same platform functionality.

## The Scope of UEFI Redfish Client EDK2 Implementation
-  Platform Configurable settings

This is the first stage of UEFI Redfish Client EDK2 Implementation. Associate
Redfish property with HII option.

- Provisioning of Firmware Managed Platform Redfish Resource

The current design of UEFI Redfish Client EDK2 Implementation can already
support the provisioning of firmware-owned platform Redfish resource, however,
this requires additional support on edk2 HII. Therefore, provisioning of
firmware managed platform Redfish resource would be the second stage.

Below are the block diagrams of UEFI Redfish Client EDK2 Implementation.

## <a name="[0]">EDK2 Redfish Client Implementation Diagrams</a>
![UEFI Redfish Client Implementation](https://github.com/tianocore/edk2-redfish-client/blob/main/RedfishClientPkg/Documents/Media/RedfishClientDriverStack.svg?raw=true)

## EFI EDK2 Redfish Client Framework
The functionality of each block in the diagrams are described in below sections,

### EDK2 Redfish Foundation ***[[1]](#[0])***
EDK2 Redfish Redfish Foundation provides the facilities of communicating with
Redfish service. Such as the discovery of Redfish service, the credential to
access Redfish service, *EFI REST EX Protocol* instance which is the transport
layer to Redfish service, and so on. Please refer to
[*EDK2 Redfish Foundation*](https://github.com/tianocore/edk2/blob/master/RedfishPkg/Readme.md).

### Redfish Profile Simulator ***[[2]](#[0])***
Redfish Profile Simulator is an
[*open source project*](https://github.com/DMTF/Redfish-Profile-Simulator) on
DMTF GitHub, which simulates the HTTP request methods (POST, PATCH, PUT, GET) on
Redfish resource maintained by Redfish Profile Simulator. EDK2 open source uses
this simulator for the use case when Redfish service has not been set up on the
platform, or for the quick Redfish firmware feature development. We clone this
project under RedfishClientPkg and maintain it by edk2 because this project has
currently been using and updating rarely. That is easier for edk2 to add
features to the simulator or modify the simulator to align with edk2 requirement
on Redfish service, such as ETAG and HTTP POST support. <br>
Another open source project of Redfish simulator is
[*Redfish Interface Emulator*](https://github.com/DMTF/Redfish-Interface-Emulator),
however, we don't pay much attention to this project because we have been
dedicating to Redfish Profile Simulator since we started the UEFI Redfish EDK2
project.

### EDK2 Redfish JSON Schema to C Structure Convertor ***[[3]](#[0])***
This is the script auto-generated EDK2 drivers and libraries that provide the
Redfish schema naming based JSON to C structure and vice versa converters. C
structure is another representation of Redfish properties other than JSON and
CSDL(XML). The higher layer Redfish client application can deal with C structure
instead of using JSON library to manipulate Redfish properties. The script
[*Redfish Schema C Struct Generator*](https://github.com/DMTF/Redfish-Schema-C-Struct-Generator)
is still a private project on DMTF GitHub. Below is the reference of script
auto-generated
[*Redfish JSON C Struct Converter Lib*](https://github.com/changab/Redfish-JSON-C-Struct-Converter-Lib)
libraries. The converters generated by the script are followed
**EFI REST JSON Structure Protocol** defined in UEFI spec 2.8, section 29.7.3.

### EDK2 Redfish Non-Collection ***[[4]](#[0])*** and Collection ***[[5]](#[0])
*** Feature Drivers EDK2 Redfish feature driver is an intermediary driver that
sits between **JSON Schema to C Structure converters** and **EFI Platform
Configuration to Redfish Protocol**. The Redfish feature driver gets and sets
the platform configuration and incorporates it with Redfish JSON schema C
structure to manipulate Redfish JSON resources. Then applies the settings from
Redfish service to platform configurations, or vice versa to update platform
configurations to Redfish service. Both EDK2 Redfish Non-Collection and
Collection Feature drivers are script auto-generated base on Redfish schema
naming. The EDK2 Redfish Non-Collection feature driver manages the resource of
specific Redfish resource type, while the EDK2 Redfish Collection feature
driver manages the members which have the same resource type in collection
resource (e.g the ComputerSystem resource and ComputerSystemCollection resource)
.

### EDKII Redfish Platform Config Protocol ***[[6]](#[0])***
EDKII Redfish Platform Config Protocol is an abstract driver that abstracts the
platform configuration format and storage from EDK2 Redfish Feature driver.
This protocol provides the interfaces to get and set platform configuration with
the format and configuration storage agnostic to the Redfish feature driver.
The platform can provide its own EDKII Redfish Platform Config driver instance
to access platform-specific configuration format and storage.

On EDK2 open source, EDKII Redfish Platform Config Protocol accesses the
platform configuration in EDK2 HII defined format. Below is driver stack diagram
which implements EDKII Redfish Platform Config Protocol. The protocol driver
leverages the HII interface to get or set the HII configuration on platform. By
following the x-UEFI-redfish Configure Language defined in UNI file, protocol
driver can find corresponding HII question for given Redfish attribute. In this
way, protocol driver creates the mapping between HII questions and Redfish
attributes.

![platform config](https://github.com/tianocore/edk2-redfish-client/blob/main/RedfishClientPkg/Documents/Media/redfish-platform-config-protocol-stack.svg?raw=true)

Below is the prototype of **EDKII_REDFISH_PLATFORM_CONFIG_PROTOCOL**,

```C
struct _EDKII_REDFISH_PLATFORM_CONFIG_PROTOCOL {
  UINT64                                                Revision;
  EDKII_REDFISH_PLATFORM_CONFIG_GET_VALUE               GetValue;
  EDKII_REDFISH_PLATFORM_CONFIG_SET_VALUE               SetValue;
  EDKII_REDFISH_PLATFORM_CONFIG_GET_DEFAULT_VALUE       GetDefaultValue;
  EDKII_REDFISH_PLATFORM_CONFIG_GET_ATTRIBUTE           GetAttribute;
  EDKII_REDFISH_PLATFORM_CONFIG_GET_CONFIG_LANG         GetConfigureLang;
  EDKII_REDFISH_PLATFORM_CONFIG_GET_SUPPORTED_SCHEMA    GetSupportedSchema;
};
```

### Other instances of EDKII Redfish Platform Config Protocol ***[[7]](#[0])***
For those Non-EDK2 HII-based platform configuration formats, the driver instance
can provide its own implementation to get or set the platform configurations.

### EDKII Redfish Feature Core DXE Driver ***[[12]](#[0])***
EDKII Redfish Feature Core DXE driver provides the protocol interface to
the auto-generated Redfish feature driver to register itself for the
Redfish resource URI it manages.

```C
struct _EDKII_REDFISH_FEATURE_PROTOCOL {
  REDFISH_FEATURE_REGISTER      Register;
  REDFISH_FEATURE_UNREGISTER    Unregister;
};
```

Redfish Feature Core DXE driver records the
URI according to the URI hierarchy, and then it starts up the Redfish
feature drivers based on the hierarchy when the particular event
***[[11]](#[0])*** is triggered. This makes sure the upper-level Redfish
resource is built up before the lower-level resource. For example,
ComputerSystem resource must be ready before the Memory resource managed
by MemoryCollection because the Memory resource is part of ComputerSystem
resource.

### Start-Up Event to Trigger EDKII Redfish Feature Core ***[[11]](#[0])***
This is an EFI event for triggering EDKII Redfish Feature Core to travel
URIs in the database and execute the callback that registered by Redfish feature
drivers. The event GUID is defined in below PCD and is default set to
**gEfiEventReadyToBootGuid**.

```C
PcdEdkIIRedfishFeatureDriverStartupEventGuid
```

This PCD can be overridden to any events based on the platform
implementation. EDKII Redfish Feature Core can be triggered earlier,
for example before the BDS or in the early DXE phase if the platform provides
the EFI REST EX protocol which is available before the BDS phase.

### EDK2 HII VFR Form ***[[8]](#[0])***
According to **UEFI spec 2.9 section 35.6 Form Browser Protocol**,
**EFI_HII_REST_STYLE_FORMSET_GUID** is used on HII form to indicate that HII
options declared in this form intend to interact with the REST architectural
style. On edk2 open source, the REST architectural style refers to the Redfish
service. Besides **EFI_HII_REST_STYLE_FORMSET_GUID** is defined in the form
scope, **EFI_IFR_FLAG_REST_STYLE** can be assigned to the HII options that
indicate those options intend to interact with the REST service.

### EDK2 HII UNI file ***[[9]](#[0])***
By following the concept of [UEFI Configuration Namespace](https://uefi.org/namespace_instructions), x-UEFI-redfish Configure
Language is created and used in UNI file to associate HII option
with the particular Redfish property. The Hii options interact with EDK2 Redfish
Feature driver if the string of HII option is assigned with x-UEFI-redfish
Language as in below,

```C
x-UEFI-redfish-$(NAMESPACE)
where $(NAMESPACE) is the combination of Redfish ResourceTypeName and schema version.
```
For example, if the HII option is mapped to the property in Processor.v1_0_0.
The x-UEFI-redfish configure language is declared as below,
```C
x-UEFI-redfish-Processor.v1_0_0
```
#### x-UEFI-redfish Configure Language format:
- The string declared with x-UEFI-redfish configure language is a path to the property
in Redfish schema.
- The root of path is the Redfish resource type indicated in x-UEFI-redfish configure
language
- The path is relative to root of [Redfish schema](https://redfish.dmtf.org/redfish/schema_index) defined by DMTF, not related to Redfish service root.

#### Examples,
```C
Properties:

#string STR_BOOT_SOURCE_OVERRIDE_ENABLED_PROMPT #language x-UEFI-redfish-ComputerSystem.v1_0_0  "/Boot/BootSourceOverrideEnabled"
#string STR_BOOT_SOURCE_OVERRIDE_MODE_PROMPT    #language x-UEFI-redfish-ComputerSystem.v1_0_0  "/Boot/BootSourceOverrideMode"
#string STR_BOOT_SOURCE_OVERRIDE_TARGET_PROMPT  #language x-UEFI-redfish-ComputerSystem.v1_0_0  "/Boot/BootSourceOverrideTarget"
```
```C
Properties in array object [NUM]:

#string STR_BOOT_ORDER_1_PROMPT  #language x-UEFI-redfish-ComputerSystem.v1_11_0  "/Boot/BootOrder/[1]/Boot0001"
#string STR_BOOT_ORDER_2_PROMPT  #language x-UEFI-redfish-ComputerSystem.v1_11_0  "/Boot/BootOrder/[2]/Boot0002"
#string STR_BOOT_ORDER_3_PROMPT  #language x-UEFI-redfish-ComputerSystem.v1_11_0  "/Boot/BootOrder/[3]/Boot0003"
```
```C
Properties in collection object {NUM}:

#string STR_MEMORY_1_BASE_MODULE_TYPE_PROMPT  #language x-UEFI-redfish-Memory.v1_7_1  "/Memory/{1}/BaseModuleType"
#string STR_MEMORY_2_BASE_MODULE_TYPE_PROMPT  #language x-UEFI-redfish-Memory.v1_7_1  "/Memory/{2}/BaseModuleType"
#string STR_MEMORY_3_BASE_MODULE_TYPE_PROMPT  #language x-UEFI-redfish-Memory.v1_7_1  "/Memory/{3}/BaseModuleType"
```

### EDK2 Build Tool ***[[10]](#[0])***
EDK2 Build is responsible to pull the necessary EDK2 Redfish JSON Schema to C
Structure Convertors and EDK2 Redfish Feature drivers into edk2 build process
according to the x-UEFI-redfish config language used in the HII VFR forms.

## EDK2 Redfish client feature driver
![foundation driver stack](https://github.com/tianocore/edk2-redfish-client/blob/main/RedfishClientPkg/Documents/Media/redfish-foundation-driver-stack.svg?raw=true)

Above diagram shows the way how Redfish application (Redfish feature driver) works with Redfish foundation
drivers and communicate with Redfish service. Redfish feature driver relies on Redfish Config driver to
provide the information of desired Rest Ex instance. To achieve this, Redfish feature driver has to provide
EDKII Redfish Config Handler Protocol and Redfish Config driver will use this protocol to deliver Redfish
service information.

```C
struct _EDKII_REDFISH_CONFIG_HANDLER_PROTOCOL {
  EDKII_REDFISH_CONFIG_HANDLER_PROTOCOL_INIT    Init;
  EDKII_REDFISH_CONFIG_HANDLER_PROTOCOL_STOP    Stop;
};
```

![feature driver call flow](https://github.com/tianocore/edk2-redfish-client/blob/main/RedfishClientPkg/Documents/Media/redfish-feature-driver-call-flow.svg?raw=true)

Above diagram shows the details of how Redfish feature core driver invokes Redfish feature drivers. To be called
by Redfish feature core driver, Redfish feature driver has to register the managed URI to Redfish feature core
driver. Then Redfish feature core driver learns the dependency of each different feature drivers.

#### Dispatch Redfish feature drivers
When given event is signaled, Redfish feature core driver starts the operation of invoking Redfish feature drivers
by following the order from parent node to child node in the Redfish URI hierarchy. In the diagram, the feature
driver which manages service root will be invoked first. And feature driver which manages computer system collection
will be invoked at second position. Once Redfish feature core driver walks through entire Redfish URI, the operation
is stopped.

### Interface between collection feature driver and non-collection feature driver
Redfish collection resource is a set of Redfish non-collection resource. Redfish collection feature driver works
with non-collection feature driver to manage them. For example, boot option collection feature driver work with
boot option feature driver to manage boot options in Redfish service. Computer system collection feature driver
work with computer system feature driver to manage computer system resource.

The interface between collection feature driver and non-collection feature driver is EDKII Redfish resource config
protocol.

```C
struct _EDKII_REDFISH_RESOURCE_CONFIG_PROTOCOL {
  EDKII_REDFISH_RESOURCE_CONFIG_PROTOCOL_PROVISIONING    Provisioning;
  EDKII_REDFISH_RESOURCE_CONFIG_PROTOCOL_CONSUME         Consume;
  EDKII_REDFISH_RESOURCE_CONFIG_PROTOCOL_UPDATE          Update;
  EDKII_REDFISH_RESOURCE_CONFIG_PROTOCOL_CHECK           Check;
  EDKII_REDFISH_RESOURCE_CONFIG_PROTOCOL_IDENTIFY        Identify;
  EDKII_REDFISH_RESOURCE_CONFIG_PROTOCOL_GET_INFO        GetInfo;
};
```

### Feature driver event
Two events are defined for feature driver to perform necessary operation at given time.
- Ready-to-Provisioning event
  - Feature driver which requires to do operation before Redfish feature driver starts the synchronization can listen to
    this event. For example, boot option feature driver may want to refresh boot order variable and get latest boot order
    information before provisioning the boot options to boot options resource.
- After-Provisioning event
  - Feature driver which wants to do operation after Redfish feature driver finish the synchronization job can listen to
    this event.

### Reboot required
When Redfish feature drivers apply user request to platform, a system reboot is usually required. PCD `gEfiRedfishClientPkgTokenSpaceGuid.PcdRedfishSystemRebootRequired` is introduced for this purpose. After Redfish feature
core driver is done with synchronization job, Redfish feature core driver checks this PCD and perform system reboot when
PCD is set to `TRUE`.

### Synchronization design between Redfish service and BIOS
The purpose of Redfish feature driver is to do the synchronization job between Redfish service and BIOS. The operation of synchronization can be simply divided into two types:

#### Provisioning resource
Below is the flow diagram of provisioning platform configuration to Redfish service at BIOS resource. With the x-UEFI-redfish
configure language described in above section, Redfish feature driver collect all BIOS attributes from HII database and populated
them to Redfish service.
![provisioning](https://github.com/tianocore/edk2-redfish-client/blob/main/RedfishClientPkg/Documents/Media/redfish-call-flow-provisioning.svg?raw=true)

#### Consume resource
Below is the flow diagram of consuming user request from Redfish service to platform configuration. Redfish feature driver finds
corresponding HII question and apply user desired value to platform.
![pending settings](https://github.com/tianocore/edk2-redfish-client/blob/main/RedfishClientPkg/Documents/Media/redfish-call-flow-pending-settings.svg?raw=true)

Below diagram shows the call flow of EDKII Resource Config Protocol and how to use this protocol to handle synchronization
job.
![synchronization](https://github.com/tianocore/edk2-redfish-client/blob/main/RedfishClientPkg/Documents/Media/redfish-synchronization-design.svg?raw=true)

Several interfaces defined in EDKII Redfish Resource Config Protocol work together to support Redfish synchronization:
- Identify()
  - This function is used to check if the given Redfish resource is the one the feature driver
    wants to manage. A platform library `RedfishResourceIdentifyLib` is introduced for
    platform to implement its own policy to identify Redfish resource.
- Check()
  - This function is used to check the attribute status on Redfish service. If all attributes
    the feature driver manages are presented in Redfish service, feature driver must provision
    them already. Otherwise, Provisioning() will be called to perform resource provisioning
    job.
- Provisioning()
  - When this function is called, feature driver will provision all attributes that it managed
    to Redfish service. This operation usually creates the new Redfish properties at the
    existing URI in Redfish service. Use HTTP PATCH to provision Redfish properties as BIOS
    may only manage some but not all of the properties of the resource. See [Redfish-edk2 implementation](#Redfish-Service-Implementation-that-Incorporates-with-EDK2-Redfish) for
    the details. HTTP POST is still used for creating a collection member, such as the
    collection member of processor or memory for the Redfish inventory management.
    However, HTTP PUT to overwrite an entire Redfish resource is not used in edk2 Redfish
    implementation as edk2 Redfish implementation has no idea of whether the Redfish resource
    is entirely managed by BIOS or not.
- Consume()
  - When there is pending settings in Redfish service, this function is called for feature
    driver to consume pending settings requested by user. HTTP GET is the method used
    to retrieve Redfish properties.
- Update()
  - When platform configuration is updated, this function is called to update configuration
    changes to Redfish service and Redfish service can show the latest settings on platform.
    HTTP PATCH is the method used to update the properties of Redfish resource.

The EDKII Redfish Resource Addendum Protocol is introduced to provide platform addendum data that Redfish service requires.
This protocol will be called at Provisioning() and Update() functions so platform can add OEM attribute or any other attribute
specified by Redfish service.

```C
struct _EDKII_REDFISH_RESOURCE_ADDENDUM_PROTOCOL {
  UINT64                                  Revision;    ///< Protocol revision
  EDKII_REDFISH_RESOURCE_ADDENDUM_OEM     GetOemData;  ///< Get OEM data
  EDKII_REDFISH_RESOURCE_ADDENDUM_DATA    GetData;     ///< Get addendum data
};
```

### <a name="Redfish-Service-Implementation-that-Incorporates-with-EDK2-Redfish"></a>Redfish Service Implementation that Incorporates with EDK2 Redfish
The idea of Redfish synchronization design is to manage Redfish resource directly by platform host
firmware. To do this, Redfish synchronization functions have to work with Redfish service implementation
in BMC firmware. This is because the mechanism between platform host firmware and BMC firmware is not
defined in any specification. Several prerequisites must be satisfied and listed below:

**BIOS Redfish Credential**

- Platform host firmware has the permission to manage Redfish resource. BMC has ability to distinguish
the in-band platform host firmware and out-of-band user, this can normally be done by identifying the bootstrap account in HTTP request. The bootstrap account is described in Host Interface specification 1.3.0 section 9. If the Redfish client uses bootstrap account for HTTP actions, BMC must consider the Redfish
client is BIOS and give the write permission to BIOS for updating BIOS managed Redfish properties even the
properties are declared as "ReadOnly" in the Redfish schema.

**BIOS Managed Redfish Resource Provisioning**
- The Default Empty BIOS Managed Redfish Resource <br>
  The BIOS managed Redfish properties may not covering the entire resource but just manages some properties
  in the resource or a subset of resource. For example, the "Boot" property in ComputerSystem. BIOS is not able to use HTTP PUT to replace a resource that is not entirely managed by BIOS. The HTTP PATCH is the only method to provision the BIOS managed properties. This is a requirement the BIOS managed properties
  in the resource must have either a default value or an empty property, with this BIOS can have a HTTP
  PATCH to update the value.<br><br>
  For the example in ComputerSystem resource below,<br>
  The "BootOrder" property is exist in ComputerSystem, however the values is left as empty. With the
  existence of "BootOrder", BIOS can provision the valid values using HTTP PATCH with out error.

```C
In Redfish Computer System resource:
{
  "Boot": {
    "AutomaticRetryAttempts": 3,
    "BootOrder": []
  }
}
```

- Computer System Bios resource<br>
The "Bios" property in Computer System resource usually has a "@odata.id" property that is an
URI points to the BIOS Redfish resource. The "Bios" property must exist in the computer system
resource and the URI of "Bios" property is required to be provided by BMC as the default value.
With this, BIOS knows where to provision the BIOS resource.

```C
In Redfish Computer System resource:
{
  "Bios": {
    "@odata.id": "/redfish/v1/Systems/system/Bios"
  }
}
```

- BIOS AttributeRegistry<br>
The "AttributeRegistry" is a property in "Bios" resource, which is the resource ID of
message registry file that has the system-specific information about a BIOS resource.
"AttributeRegistry" must exist in "Bios" resource and the value can't be empty if the the
platform support system-specific information BIOS resource. In order to provision the BIOS
attribute registry resource, BIOS attribute registry must be defined as a collection member
in the service root "Registries" collection property. The value of "Id" property in
MessageFileRegistry must be as the same as "AttributeRegistry" value in BIOS resource.
Also, the "Languages" and "Location" array property must be predefined in the Redfish message
file. The location URI of message registry file can be determined by BMC. With this, BIOS can get the resource ID from "AttributeRegistry" property and look for the same ID defined in the
Message File Registry collection for provisioning the entire BIOS AttributeRegistry resource.

```C
In Redfish Computer System Bios resource:
{
  "AttributeRegistry": "BiosAttributeRegistry"
}

In Service Root Registries resource:
{
  "Members": [
    {
      "@odata.id": "/redfish/v1/Registries/BiosAttributeRegistry"
    }
  ]
}

In /redfish/v1/Registries/BiosAttributeRegistry:
{
  "Id": "BiosAttributeRegistry",
  "Languages": [
    "en"
  ],
  "Languages@odata.count": 1,
  "Location": [
    {
      "Language": "en",
      "Uri": "/redfish/v1/Registries/Bios"
    }
  ]
}

The URI "/redfish/v1/Registries/Bios" is where BIOS to put the BIOS attribute registry resource.
```

**BIOS Managed Redfish Resource Consumption**

The ability to tell if there are the changes on BIOS managed Redfish resource. The modifications to BIOS managed resource is considered as an asynchronous operation because the Redfish feature drivers can only be
executed at the platform host firmware POST time. With the above constraint, we need the below requirements
on BMC Redfish service.
  - ETAG Support in HTTP Header<br>
  To reduce the unnecessary HTTP GET for the unchanged Redfish resource that leads to increase the platform
  boot time, ETAG is leveraged to tell BIOS if BIOS has to get the entire resource as there were some
  changes made on the resource. Although ETAG support in HTTP response header is not mandatory by edk2
  Redfish design, it is still a strong recommendation if the platform boot time is a concern. <br>
  Below PCD is used to configure the BMC Redfish service supports ETAG.

```C
  gEfiRedfishClientPkgTokenSpaceGuid.PcdRedfishServiceEtagSupported
```

  - HTTP Query Head Support<br>
  In order to retrieve the HTTP response headers only to reduce the unnecessary HTTP GET for the entire
  Redfish resource. HTTP Query Head support on Redfish service is mandatory if the system boot time is a
  concern.

  - Redfish Setting Annotation Support (defined in Redfish specification 1.18 section 9.10).<br>
  @Redfish.Settings annotation represents the future state of resource. The future state of BIOS managed
  properties will be consume in the next time platform boot, no matter it is a reset cycle or power cycle.<br>
  This is a requirement for BMC Redfish service having @Redfish.Settings for the changed properties made by
  remote user. With the @Redfish.Settings annotation in the resource, BIOS can identify which Redfish
  properties were changed.  BIOS can then only consume these changes and apply those to BIOS platform
  configurations. Without providing @Redfish.Settings for the changes, BIOS can just consume all of the
  BIOS managed properties on Redfish service even the properties weren't changed.

  - ETAG Support in Redfish Setting Annotation<br>
  ETAG in @Redfish.Settings resource is also required. As @Redfish.Settings annotation may not be deleted by
  BMC after it has been consumed, the out of date @Redfish.Settings may still leave in the Redfish
  resource. With ETAG is provided in @Redfish.Settings, BIOS is able to tell if @Redfish.Settings is fresh
  or stale.<br><br>
  Below is the example of @Redfish.Settings for BIOS attribute change,

```C
  "@Redfish.Settings": {
    "@odata.type": "#Settings.v1_3_3.Settings",
    "SettingsObject": {
      "@odata.id": "/redfish/v1/Systems/1/Bios",
      "@odata.etag": "W/\"ABCDEFG\"",
      "Attributes": {
        "BootMode": "Uefi"
      }
    }
  }
```

**Redfish HTTP Content Encoding**<br>
For the performance consideration when BIOS HTTP POST, PUT and PATCH the resource, HTTP Content-Encoding
header is leverage to compress the resource to reduce the payload size with BMC Redfish support. Below PCD string is introduced for platform developer to set the encoding method supported by BMC Redfish, currently
only "None" and "gzip" are supported.

```C
  gEfiRedfishPkgTokenSpaceGuid.PcdRedfishServiceContentEncoding|["None"]["gzip"]
```

**BIOS Redfish Action**
- Redfish supports the HTTP POST and DELETE operation<br>
HTTP POST operation is triggered by BIOS to create a Redfish collection member in the Redfish
collection resource, and also for triggering the Redfish action. For the Redfish action, such
as loading the BIOS default and Secure boot certification enrollment.<br>
HTTP DELETE operation is triggered by BIOS to delete a member in the Redfish collection.

### Redfish Task
Redfish task service driver handles Redfish task resources at `/redfish/v1/TaskService/Tasks` and dispatch the task
resource to registered Redfish feature driver. Redfish feature driver utilizes Redfish task protocol to get data
from registered Redfish task, and perform corresponding action specified by the Redfish task. After job is finished,
Redfish task service reports task result back to BMC. So user can check task state to see if issued task is done
successfully or not.

Redfish task is handled before any other Redfish resource because the action requested by Redfish task may change host configuration.

There are several interfaces supported by Redfish task protocol:
```C
struct _EDKII_REDFISH_TASK_PROTOCOL {
  UINT32                         Version;
  REDFISH_TASK_REGISTER          Register;
  REDFISH_TASK_UNREGISTER        Unregister;
  REDFISH_TASK_REPORT_MESSAGE    ReportMessage;
  REDFISH_TASK_GET_PAYLOAD       GetPayload;
  REDFISH_TASK_FREE_PAYLOAD      FreePayload;
};
```
- Register()
  - Redfish feature driver register its callback function and provide the task URI which is wants to handle. `PartialMatch` parameter allows feature driver to handle the task URI when certain keyword is presented.
- Unregister()
  - Redfish feature driver unregister itself and Redfish task service won't notify it anymore.
- ReportMessage()
  - When Redfish feature driver perform task given job and there is message that driver wants to send to user, feature driver calls this function and Redfish task service will send these messages to BMC. Typical use case is when there is error happens and task is failing, feature driver provides the reason why task is failing by calling this function.
- GetPayload()
  - Feature driver calls this function to get Redfish payload attached to this task resource.
- FreePayload()
  - The function that helps feature driver to release Redfish payload that is returned by GetPayload().

**Redfish task library**

Redfish task service reads Redfish tasks on  `/redfish/v1/TaskService/Tasks`. However, the URI for host firmware to update task results and state are not defined in any specification. As the result, platform BMC may have different implementation of updating task result. This makes the interface of updating Redfish task to be platform dependent. Redfish task library is introduced for platform owner to implement this path.

## The Contributors
Chang, Abner <abner.chang@amd.com>\
Wang, Nickle <nicklew@nvidia.com>\
Chen, Aaron <aaron.chen@hpe.com>
